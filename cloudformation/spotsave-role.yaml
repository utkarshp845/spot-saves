AWSTemplateFormatVersion: '2010-09-09'
Description: 'SpotSave Read-Only IAM Role - Allows SpotSave to scan your AWS account for cost savings opportunities'

Parameters:
  SpotSaveAccountId:
    Type: String
    Description: Your SpotSave service account ID (provided by SpotSave)
    NoEcho: false
  
  ExternalId:
    Type: String
    Description: Unique external ID for security (auto-generated)
    Default: ''
  
  RoleName:
    Type: String
    Description: Name for the IAM role
    Default: 'SpotSaveRole'

Resources:
  # SSM Parameter is created by the Lambda function, no need for separate resource

  # Lambda execution role for the custom resource handler
  RoleHandlerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: IAMRoleManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:GetRole'
                  - 'iam:CreateRole'
                  - 'iam:UpdateAssumeRolePolicy'
                  - 'iam:AttachRolePolicy'
                  - 'iam:ListAttachedRolePolicies'
                  - 'iam:GetRolePolicy'
                  - 'iam:PutRolePolicy'
                  - 'iam:TagRole'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'ssm:PutParameter'
                  - 'ssm:GetParameter'
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/spotsave/*'

  # Lambda function to handle role creation/updates (handles existing roles gracefully)
  RoleHandlerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-RoleHandler'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt RoleHandlerExecutionRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          import uuid
          import urllib.request
          import urllib.error
          import traceback
          import time
          from botocore.exceptions import ClientError

          # Inline cfnresponse implementation
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"

          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              responseBody = {
                  'Status': responseStatus,
                  'Reason': 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,
                  'PhysicalResourceId': physicalResourceId or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': noEcho,
                  'Data': responseData
              }
              json_responseBody = json.dumps(responseBody)
              json_responseBody_bytes = json_responseBody.encode('utf-8')
              
              max_retries = 3
              for attempt in range(max_retries):
                  try:
                      req = urllib.request.Request(responseUrl, data=json_responseBody_bytes, method='PUT')
                      req.add_header('Content-Type', '')
                      req.add_header('Content-Length', str(len(json_responseBody_bytes)))
                      
                      with urllib.request.urlopen(req, timeout=30) as response:
                          status_code = response.getcode()
                          print(f"Response sent successfully. Status code: {status_code}")
                          if status_code == 200:
                              return
                  except urllib.error.HTTPError as e:
                      print(f"HTTP Error (attempt {attempt + 1}/{max_retries}): {e.code} - {e.reason}")
                      if attempt == max_retries - 1:
                          raise
                      time.sleep(1)
                  except Exception as e:
                      print(f"Error sending response (attempt {attempt + 1}/{max_retries}): {str(e)}")
                      if attempt == max_retries - 1:
                          raise
                      time.sleep(1)

          iam = boto3.client('iam')

          def lambda_handler(event, context):
              """
              CloudFormation custom resource handler for SpotSave IAM Role.
              Handles existing roles gracefully by checking if they exist first.
              """
              print(f"Received event: {json.dumps(event)}")
              
              request_type = event['RequestType']
              role_name = event['ResourceProperties']['RoleName']
              spotsave_account_id = event['ResourceProperties']['SpotSaveAccountId']
              external_id_param = event['ResourceProperties'].get('ExternalId', '')
              managed_policy_arns = event['ResourceProperties'].get('ManagedPolicyArns', [])
              inline_policy_name = event['ResourceProperties'].get('InlinePolicyName', '')
              inline_policy_document = event['ResourceProperties'].get('InlinePolicyDocument', {})
              tags = event['ResourceProperties'].get('Tags', [])
              
              response_data = {}
              ssm = boto3.client('ssm')
              
              try:
                  # Check if role exists
                  role_arn = None
                  try:
                      existing_role = iam.get_role(RoleName=role_name)
                      role_exists = True
                      role_arn = existing_role['Role']['Arn']
                      print(f"Role {role_name} already exists: {role_arn}")
                  except ClientError as e:
                      error_code = e.response.get('Error', {}).get('Code', '')
                      if error_code == 'NoSuchEntity':
                          role_exists = False
                          print(f"Role {role_name} does not exist, will create it")
                      else:
                          raise
                  except Exception as e:
                      print(f"Unexpected error checking role: {e}")
                      raise
                  
                  # Get or generate external ID
                  if external_id_param:
                      external_id = external_id_param
                  else:
                      # Try to get existing external ID from SSM
                      ssm_param_name = f'/spotsave/{role_name}/external-id'
                      try:
                          existing_param = ssm.get_parameter(Name=ssm_param_name)
                          external_id = existing_param['Parameter']['Value']
                          print(f"Retrieved existing external ID from SSM: {ssm_param_name}")
                      except Exception as e:
                          # Parameter not found or other error - generate new external ID
                          error_code = ''
                          if hasattr(e, 'response'):
                              try:
                                  error_code = e.response.get('Error', {}).get('Code', '')
                              except:
                                  pass
                          elif hasattr(e, '__class__'):
                              error_name = e.__class__.__name__
                              if 'ParameterNotFound' in error_name or 'NotFound' in error_name:
                                  error_code = 'ParameterNotFound'
                          
                          if error_code == 'ParameterNotFound':
                              print(f"External ID not found in SSM, generating new one")
                          else:
                              print(f"Warning: Could not retrieve from SSM (error: {type(e).__name__}): {str(e)}, generating new external ID")
                          external_id = str(uuid.uuid4())
                  
                  if request_type == 'Delete':
                      # On delete, we don't delete the role (let user manage it)
                      # Just return success
                      print(f"Delete requested for role {role_name}, but role will be retained")
                      send(event, context, SUCCESS, response_data)
                      return
                  
                  if not role_exists:
                      # Create the role
                      print(f"Creating role {role_name}...")
                      
                      # Build assume role policy
                      assume_role_policy = {
                          "Version": "2012-10-17",
                          "Statement": [
                              {
                                  "Effect": "Allow",
                                  "Principal": {
                                      "AWS": f"arn:aws:iam::{spotsave_account_id}:root"
                                  },
                                  "Action": "sts:AssumeRole"
                              }
                          ]
                      }
                      
                      # Add external ID condition if provided
                      if external_id:
                          assume_role_policy["Statement"][0]["Condition"] = {
                              "StringEquals": {
                                  "sts:ExternalId": external_id
                              }
                          }
                      
                      # Create role
                      create_role_response = iam.create_role(
                          RoleName=role_name,
                          AssumeRolePolicyDocument=json.dumps(assume_role_policy),
                          Tags=[{'Key': tag['Key'], 'Value': tag['Value']} for tag in tags] if tags else []
                      )
                      role_arn = create_role_response['Role']['Arn']
                      print(f"Role created: {role_arn}")
                  else:
                      # Role exists - update assume role policy if needed
                      print(f"Updating assume role policy for existing role {role_name}...")
                      
                      assume_role_policy = {
                          "Version": "2012-10-17",
                          "Statement": [
                              {
                                  "Effect": "Allow",
                                  "Principal": {
                                      "AWS": f"arn:aws:iam::{spotsave_account_id}:root"
                                  },
                                  "Action": "sts:AssumeRole"
                              }
                          ]
                      }
                      
                      if external_id:
                          assume_role_policy["Statement"][0]["Condition"] = {
                              "StringEquals": {
                                  "sts:ExternalId": external_id
                              }
                          }
                      
                      iam.update_assume_role_policy(
                          RoleName=role_name,
                          PolicyDocument=json.dumps(assume_role_policy)
                      )
                  
                  # Attach managed policies (idempotent - safe to call multiple times)
                  # First, check which policies are already attached
                  try:
                      attached_policies_response = iam.list_attached_role_policies(RoleName=role_name)
                      attached_policy_arns = [p['PolicyArn'] for p in attached_policies_response['AttachedPolicies']]
                  except Exception as e:
                      print(f"Warning: Could not list attached policies: {e}")
                      attached_policy_arns = []
                  
                  for policy_arn in managed_policy_arns:
                      if policy_arn in attached_policy_arns:
                          print(f"Policy {policy_arn} already attached, skipping")
                          continue
                      
                      try:
                          iam.attach_role_policy(
                              RoleName=role_name,
                              PolicyArn=policy_arn
                          )
                          print(f"Attached managed policy: {policy_arn}")
                      except ClientError as e:
                          error_code = e.response.get('Error', {}).get('Code', '')
                          if error_code == 'PolicyNotAttachable':
                              print(f"Warning: Could not attach policy {policy_arn}: {e}")
                          else:
                              raise
                      except Exception as e:
                          # Check if it got attached despite the error
                          try:
                              attached_policies = iam.list_attached_role_policies(RoleName=role_name)
                              if policy_arn in [p['PolicyArn'] for p in attached_policies['AttachedPolicies']]:
                                  print(f"Policy {policy_arn} is now attached")
                              else:
                                  print(f"Warning: Error attaching policy {policy_arn}: {e}")
                          except:
                              print(f"Warning: Error verifying policy attachment {policy_arn}: {e}")
                  
                  # Handle inline policy (check if exists first, then create or update)
                  if inline_policy_name and inline_policy_document:
                      try:
                          # Try to get existing policy
                          try:
                              existing_policy = iam.get_role_policy(
                                  RoleName=role_name,
                                  PolicyName=inline_policy_name
                              )
                              # Policy exists, update it
                              print(f"Updating existing inline policy: {inline_policy_name}")
                              iam.put_role_policy(
                                  RoleName=role_name,
                                  PolicyName=inline_policy_name,
                                  PolicyDocument=json.dumps(inline_policy_document)
                              )
                          except ClientError as e:
                              error_code = e.response.get('Error', {}).get('Code', '')
                              if error_code == 'NoSuchEntity':
                                  # Policy doesn't exist, create it
                                  print(f"Creating inline policy: {inline_policy_name}")
                              else:
                                  raise
                              iam.put_role_policy(
                                  RoleName=role_name,
                                  PolicyName=inline_policy_name,
                                  PolicyDocument=json.dumps(inline_policy_document)
                              )
                      except Exception as e:
                          print(f"Warning: Error handling inline policy {inline_policy_name}: {e}")
                          # Don't fail the whole operation if policy update fails
                  
                  # Store external ID in SSM Parameter (if not already stored)
                  ssm_param_name = f'/spotsave/{role_name}/external-id'
                  try:
                      ssm.put_parameter(
                          Name=ssm_param_name,
                          Value=external_id,
                          Type='String',
                          Description='SpotSave External ID - Keep this secure',
                          Overwrite=True
                      )
                      print(f"Stored external ID in SSM: {ssm_param_name}")
                  except Exception as e:
                      print(f"Warning: Could not store in SSM: {e}")
                  
                  # Ensure role_arn is set
                  if not role_arn:
                      raise Exception("role_arn was not set - this should not happen")
                  
                  response_data['RoleArn'] = role_arn
                  response_data['RoleName'] = role_name
                  response_data['ExternalId'] = external_id
                  
                  print(f"Success! Role ARN: {role_arn}, External ID: {external_id}")
                  send(event, context, SUCCESS, response_data)
                  
              except Exception as e:
                  error_msg = str(e)
                  error_trace = traceback.format_exc()
                  print(f"Error: {error_msg}")
                  print(f"Traceback: {error_trace}")
                  response_data['Error'] = error_msg
                  try:
                      send(event, context, FAILED, response_data)
                  except Exception as send_error:
                      print(f"CRITICAL: Failed to send FAILED response: {send_error}")
                      # Last resort - try one more time
                      try:
                          send(event, context, FAILED, {'Error': 'Failed to send detailed error'})
                      except:
                          print("CRITICAL: Could not send any response to CloudFormation")
                          raise

  # Custom resource that uses the Lambda to create/manage the role
  SpotSaveRole:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt RoleHandlerFunction.Arn
      RoleName: !Ref RoleName
      SpotSaveAccountId: !Ref SpotSaveAccountId
      ExternalId: !If 
        - HasExternalId
        - !Ref ExternalId
        - ''
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/job-function/Billing'
        - 'arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess'
        - 'arn:aws:iam::aws:policy/AWSPriceListServiceFullAccess'
        - 'arn:aws:iam::aws:policy/AmazonRDSReadOnlyAccess'
        - 'arn:aws:iam::aws:policy/AWSLambda_ReadOnlyAccess'
      InlinePolicyName: SpotSaveCloudWatchRead
      InlinePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'cloudwatch:GetMetricStatistics'
              - 'cloudwatch:ListMetrics'
              - 'cloudwatch:GetMetricData'
              - 'cloudwatch:DescribeAlarms'
            Resource: '*'
      Tags:
        - Key: ManagedBy
          Value: SpotSave
        - Key: Purpose
          Value: CostOptimizationScanning

Conditions:
  HasExternalId: !Not [!Equals [!Ref ExternalId, '']]

Outputs:
  RoleArn:
    Description: 'IAM Role ARN - Use this in SpotSave'
    Value: !GetAtt SpotSaveRole.RoleArn
    Export:
      Name: !Sub '${AWS::StackName}-RoleArn'
  
  ExternalId:
    Description: 'External ID - Use this in SpotSave (Keep secure!)'
    Value: !GetAtt SpotSaveRole.ExternalId
    Export:
      Name: !Sub '${AWS::StackName}-ExternalId'
  
  SetupInstructions:
    Description: 'Next steps'
    Value: !Sub |
      Setup Complete!
      
      1. Copy the Role ARN: ${SpotSaveRole.RoleArn}
      2. Copy the External ID: ${SpotSaveRole.ExternalId}
      3. Go to your SpotSave dashboard
      4. Enter these values to start scanning

